package org.rascalmpl.values.synclj;

//This code was generated by Rascal API gen
import java.util.HashMap;
import java.util.Map;

import org.rascalmpl.interpreter.types.RascalTypeFactory;
import org.eclipse.imp.pdb.facts.type.Type;
import org.eclipse.imp.pdb.facts.type.TypeFactory;
import org.eclipse.imp.pdb.facts.type.TypeStore;
import org.eclipse.imp.pdb.facts.*;

public class MetaGrammar {
	public static TypeStore typestore = new TypeStore(
			org.rascalmpl.values.errors.Factory.getStore(),
			org.rascalmpl.values.locations.Factory.getStore());

	private static TypeFactory tf = TypeFactory.getInstance();
	private static RascalTypeFactory rtf = RascalTypeFactory.getInstance();

	public static final Type MetaGrammar = tf.abstractDataType(typestore,
			"MetaGrammar");
	
	// this assumes constructors are unique across ADT types.
	private static final Map<String, Type> consToTypeMap = new HashMap<String, Type>();
	
	private static Type makeConstructor(TypeStore ts, Type type, String cons, Object ...args) {
		Type t = makeConstructor(ts, type, cons, args);
		consToTypeMap.put(cons, t);
		return t;
	}
	
	public static Type getTypeForName(String name) {
		return consToTypeMap.get(name);
	}

	public static final Type Rule = tf.abstractDataType(typestore, "Rule");

	public static final Type MetaGrammar_grammar = makeConstructor(typestore,
			MetaGrammar, "grammar", tf.listType(Rule), "rules");

	public static final Type Alt = tf.abstractDataType(typestore, "Alt");

	public static final Type Rule_rule = makeConstructor(typestore, Rule,
			"rule", tf.stringType(), "name", tf.listType(Alt), "alts");

	public static final Type Exp = tf.abstractDataType(typestore, "Exp");

	public static final Type Alt_alt = makeConstructor(typestore, Alt, "alt",
			tf.stringType(), "name", tf.listType(Exp), "elements");

	public static final Type Exp_keyword = makeConstructor(typestore, Exp,
			"keyword");
	public static final Type Exp_regexp = makeConstructor(typestore, Exp,
			"regexp");
	public static final Type Exp_qquote = makeConstructor(typestore, Exp,
			"qquote", Exp, "arg");
	public static final Type Exp_number = makeConstructor(typestore, Exp,
			"number");
	public static final Type Exp_metaIdent = makeConstructor(typestore, Exp,
			"metaIdent");
	public static final Type Exp_vectorLit = makeConstructor(typestore, Exp,
			"vectorLit", tf.listType(Exp), "args");
	public static final Type Exp_setLit = makeConstructor(typestore, Exp,
			"setLit", tf.listType(Exp), "args");
	public static final Type Exp_metaMap = makeConstructor(typestore, Exp,
			"metaMap", tf.listType(Exp), "args");
	public static final Type Exp_rational = makeConstructor(typestore, Exp,
			"rational");
	public static final Type Exp_unquote = makeConstructor(typestore, Exp,
			"unquote", Exp, "arg");
	public static final Type Exp_listLit = makeConstructor(typestore, Exp,
			"listLit", tf.listType(Exp), "args");
	public static final Type Exp_nonTerminal = makeConstructor(typestore, Exp,
			"nonTerminal", tf.stringType(), "name");
	public static final Type Exp_mapLit = makeConstructor(typestore, Exp,
			"mapLit", tf.listType(Exp), "args");
	public static final Type Exp_form = makeConstructor(typestore, Exp, "form");
	public static final Type Exp_literal = makeConstructor(typestore, Exp,
			"literal", tf.stringType(), "text");
	public static final Type Exp_plus = makeConstructor(typestore, Exp, "plus",
			Exp, "arg");
	public static final Type Exp_symbol = makeConstructor(typestore, Exp,
			"symbol");
	public static final Type Exp_plusSep = makeConstructor(typestore, Exp,
			"plusSep", Exp, "arg", tf.stringType(), "sep");
	public static final Type Exp_float = tf
			.constructor(typestore, Exp, "float");
	public static final Type Exp_quote = makeConstructor(typestore, Exp,
			"quote", Exp, "arg");
	public static final Type Exp_integer = makeConstructor(typestore, Exp,
			"integer");
	public static final Type Exp_string = makeConstructor(typestore, Exp,
			"string");
	public static final Type Exp_opt = makeConstructor(typestore, Exp, "opt",
			Exp, "arg");
	public static final Type Exp_deref = makeConstructor(typestore, Exp,
			"deref", Exp, "arg");
	public static final Type Exp_star = makeConstructor(typestore, Exp, "star",
			Exp, "arg");
	public static final Type Exp_unquotes = makeConstructor(typestore, Exp,
			"unquotes", Exp, "arg");
	public static final Type Exp_starSep = makeConstructor(typestore, Exp,
			"starSep", Exp, "arg", tf.stringType(), "sep");
	public static final Type Exp_metaString = makeConstructor(typestore, Exp,
			"metaString");
	public static final Type Exp_char = makeConstructor(typestore, Exp, "char");
	public static final Type Exp_fnLit = makeConstructor(typestore, Exp,
			"fnLit", tf.listType(Exp), "args");

	public static IList MetaGrammar_grammar_rules(IConstructor c) {
		return (IList) c.get(0);
	}

	public static String Rule_rule_name(IConstructor c) {
		return ((IString) c.get(0)).getValue();
	}

	public static IList Rule_rule_alts(IConstructor c) {
		return (IList) c.get(1);
	}

	public static String Alt_alt_name(IConstructor c) {
		return ((IString) c.get(0)).getValue();
	}

	public static IList Alt_alt_elements(IConstructor c) {
		return (IList) c.get(1);
	}

	public static IConstructor Exp_qquote_arg(IConstructor c) {
		return (IConstructor) c.get(0);
	}

	public static IList Exp_vectorLit_args(IConstructor c) {
		return (IList) c.get(0);
	}

	public static IList Exp_setLit_args(IConstructor c) {
		return (IList) c.get(0);
	}

	public static IList Exp_metaMap_args(IConstructor c) {
		return (IList) c.get(0);
	}

	public static IConstructor Exp_unquote_arg(IConstructor c) {
		return (IConstructor) c.get(0);
	}

	public static IList Exp_listLit_args(IConstructor c) {
		return (IList) c.get(0);
	}

	public static String Exp_nonTerminal_name(IConstructor c) {
		return ((IString) c.get(0)).getValue();
	}

	public static IList Exp_mapLit_args(IConstructor c) {
		return (IList) c.get(0);
	}

	public static String Exp_literal_text(IConstructor c) {
		return ((IString) c.get(0)).getValue();
	}

	public static IConstructor Exp_plus_arg(IConstructor c) {
		return (IConstructor) c.get(0);
	}

	public static IConstructor Exp_plusSep_arg(IConstructor c) {
		return (IConstructor) c.get(0);
	}

	public static String Exp_plusSep_sep(IConstructor c) {
		return ((IString) c.get(1)).getValue();
	}

	public static IConstructor Exp_quote_arg(IConstructor c) {
		return (IConstructor) c.get(0);
	}

	public static IConstructor Exp_opt_arg(IConstructor c) {
		return (IConstructor) c.get(0);
	}

	public static IConstructor Exp_deref_arg(IConstructor c) {
		return (IConstructor) c.get(0);
	}

	public static IConstructor Exp_star_arg(IConstructor c) {
		return (IConstructor) c.get(0);
	}

	public static IConstructor Exp_unquotes_arg(IConstructor c) {
		return (IConstructor) c.get(0);
	}

	public static IConstructor Exp_starSep_arg(IConstructor c) {
		return (IConstructor) c.get(0);
	}

	public static String Exp_starSep_sep(IConstructor c) {
		return ((IString) c.get(1)).getValue();
	}

	public static IList Exp_fnLit_args(IConstructor c) {
		return (IList) c.get(0);
	}

	private static final class InstanceHolder {
		public final static MetaGrammar factory = new MetaGrammar();
	}

	public static MetaGrammar getInstance() {
		return InstanceHolder.factory;
	}

	public static TypeStore getStore() {
		return typestore;
	}
}